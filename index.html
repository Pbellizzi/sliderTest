<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<style>
    *{
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }
    body{
        width: 100vw;
        height: 100vh;
        background-color: black;
        margin: 0rem;
        overflow: hidden;
    }
    #track > img{
        width: 40vmin;
        height: 56vmin;
        object-fit: cover;
        object-position: 100% center;
        user-select: none;

        /* For Opera and <= IE9, we need to add unselectable="on" attribute onto each element */
        /* Check this site for more details: http://help.dottoro.com/lhwdpnva.php */
             -moz-user-select: none; /* These user-select properties are inheritable, used to prevent text selection */
            -webkit-user-select: none;
            -ms-user-select: none; /* From IE10 only */
            user-select: none; /* Not valid CSS yet, as of July 2012 */

            -webkit-user-drag: none; /* Prevents dragging of images/divs etc */
    }

    #track{
        display: flex;
        gap: 3vmin;
        position: absolute;
        left: 40%;
        top: 50%;
        transform: translate(0%, -50%);
    } 
</style>

<body>
    <div id="track" data-mouse-down-at="0" data-prev-percentage="0" data-prev-position="50" draggable="false" onDragStart="{(e) => e.preventDefault()}">

        <img class="image" src="imagenes/1.avif" draggable="false" onDragStart="{(e) => e.preventDefault()}"/>
        <img class="image" src="imagenes/2.avif" draggable="false" onDragStart="{(e) => e.preventDefault()}"/>
        <img class="image" src="imagenes/3.avif" draggable="false" onDragStart="{(e) => e.preventDefault()}"/>
        <img class="image" src="imagenes/4.avif" draggable="false" onDragStart="{(e) => e.preventDefault()}"/>
        <img class="image" src="imagenes/5.avif" draggable="false" onDragStart="{(e) => e.preventDefault()}"/>
        <img class="image" src="imagenes/6.avif" draggable="false" onDragStart="{(e) => e.preventDefault()}"/>
        <img class="image" src="imagenes/7.avif" draggable="false" onDragStart="{(e) => e.preventDefault()}"/>
        <img class="image" src="imagenes/8.avif" draggable="false" onDragStart="{(e) => e.preventDefault()}"/>
    </div>

</body>
<script>

    document.addEventListener("DOMContentLoaded", () => {

    const track = document.querySelector("#track");

     const handleOnDown = e => {
        track.dataset.mouseDownAt = e.clientX;
    }

    const handleOnUp = () => {
        track.dataset.mouseDownAt = "0";
        track.dataset.prevPercentage = track.dataset.percentage;
    }

    const handleOnMove = e => {
         if(track.dataset.mouseDownAt === "0") return

        const   mouseDelta = parseFloat(track.dataset.mouseDownAt) - e.clientX; 
        
        /* No estoy usando el ancho de la pantalla para determinar la velocidad del scroll*/
        /*const   maxDelta = window.innerWidth / 2;*/ 
        
        const   percentage = (mouseDelta / /*maxDelta*/ 2500) * -100;
        
        const nextPercentageUnconstrained = parseFloat(track.dataset.prevPercentage) + percentage;
        const nextPercentage = Math.max(Math.min(nextPercentageUnconstrained, 0), -100);

        track.dataset.percentage = nextPercentage;

        track.animate({
            transform: `translate(${nextPercentage}%, -50%)`
        }, {duration: 1200, fill: "forwards"});

       for (const image of [...document.querySelectorAll('.image')]){                    
        image.animate({
            objectPosition: `${nextPercentage + 100}% center`
        }, {duration: 1200, fill: "forwards"});

    }
}

        window.addEventListener("mousedown" , e =>  handleOnDown(e) );
        window.addEventListener("mouseup"   , e =>  handleOnUp(e)   );
        window.addEventListener("mousemove" , e =>  handleOnMove(e) );

        /*  ReemplacÃ© los onmouse por addEventListener

            window.onmousedown = e =>   handleOnDown(e);
            window.onmousemove = e => handleOnMove(e);
            window.onmouseup = e => handleOnUp(e); */
        /*
            Para que ande en mobile, lo dejo para despues:
            
        window.ontouchstart = e => handleOnDown(e.touches[0]);
        window.ontouchend = e => handleOnUp(e.touches[0]);
        window.ontouchmove = e => handleOnMove(e.touches[0]);
        */
})

/*I would have suggested that mouse down starts a function that stores all stages of the slider 
and mouse move and mouseup are only created inside this function and destroyed upon mouseup. 
This way you don't leave untracked window listeners and you don't need html state updates.

*/
</script>

</html>